/** * Copyright (C), 2015-2020, XXX有限公司 * FileName: MathFunctions * Author:   Administrator * Date:     2020/8/21 14:27 * Description: * History: * <author>          <time>          <version>          <desc> * 作者姓名           修改时间           版本号              描述 */package com.example.sicp.utils;import java.util.Random;/** * 〈一句话功能简述〉<br> * 〈〉 * * @author Administrator * @create 2020/8/21 * @since 1.0.0 */public class MathFunctions {    public static int getSquare(int x) {        return x * x;    }    /**     * 求一个正整数的阶乘     * 线性递归求法     *     * @param x     * @return     */    public static int getFactorial(int x) {        if (x == 1) {            return x;        } else {            return x * getFactorial(x - 1);        }    }    /**     * 一个正整数阶乘的线性迭代求法     *     * @param x     * @return     */    public static int getFactorialByIterator(int x) {        return getIterator(1, 1, x);    }    public static int getIterator(int counter, int product, int maxCount) {        if (counter > maxCount) {            return product;        } else {            return getIterator(counter + 1, counter * product, maxCount);        }    }    /**     * Ackermann函数     *     * @param x     * @param y     * @return     */    public static int getAckermann(int x, int y) {        if (y == 0) {            return 0;        } else if (x == 0) {            return 2 * y;        } else if (y == 1) {            return 2;        } else {            return getAckermann((x - 1), getAckermann(x, y - 1));        }    }    /**     * 斐波那契数递归求法     *     * @param n     * @return     */    public static int fibonacci(int n) {        if (n == 0) {            return 0;        } else if (n == 1) {            return 1;        } else {            return fibonacci(n - 1) + fibonacci(n - 2);        }    }    public static int fibonacciForIterator(int n) {        return fibIter(1, 0, n);    }    public static int fibIter(int a, int b, int count) {        if (count == 0) {            return b;        } else {            return fibIter(a + b, a, count - 1);        }    }    /**     * 根据输入的硬币种类数，返回最大的硬币面额     * 硬币面额有1,5,10,25,50美分     *     * @param kindsOfCoins     * @return     */    public static int getFirstDeminationOfCoins(int kindsOfCoins) {        if (kindsOfCoins == 1) {            return 1;        } else if (kindsOfCoins == 2) {            return 5;        } else if (kindsOfCoins == 3) {            return 10;        } else if (kindsOfCoins == 4) {            return 25;        } else if (kindsOfCoins == 5) {            return 50;        } else {        }        return 0;    }    /**     * 树形递归换零钱求法     *     * @param amount     * @return     */    public static int countChange(int amount, int kindsOfCoins) {        if (amount == 0) {            return 1;        } else if (amount < 0 || kindsOfCoins == 0) {            return 0;        } else {            return countChange(amount, kindsOfCoins - 1)                    + countChange(amount - getFirstDeminationOfCoins(kindsOfCoins), kindsOfCoins);        }    }    /**     * 换零钱线性迭代求法     * A[0][n] = 0;     * A[1][n] = A[0][n]+A[1][n-1](n>=1)     * A[2][n] = A[1][n]+A[2][n-1](n>=5)     * A[3][n] = A[2][n]+A[3][n-1](n>=10)     * A[4][n] = A[3][n]+A[4][n-1](n>=25)     * A[5][n] = A[4][n]+A[5][n-1](n>=50)     *     * @param n     * @return     */    public static int amountChangeByIterator(int n) {        int[] A = new int[n + 1];        int[] kinds = {1, 5, 10, 25, 50};        A[0] = 1;        for (int i = 0; i < 5; i++) {            for (int j = kinds[i]; j <= n; j++) {                A[j] = A[j] + A[j - kinds[i]];            }        }        return A[n];    }    /**     * 如果n<3，f(n)= n;如果n>=3,f(n)=f(n-1)+2*f(n-2)+3*f(n-3)     * 线性迭代求法     *     * @param a     * @param b     * @param c     * @param n     * @return     */    public static int getFn(int a, int b, int c, int n) {        if (n < 3) {            return n;        } else if (n == 3) {            return a + 2 * b + 3 * c;        } else {            return getFn(a + 2 * b + 3 * c, a, b, n - 1);        }    }    public static int getFn(int n) {        return getFn(2, 1, 0, n);    }    /**     * 利用递归计算出帕斯卡三角形     *     * @param n     * @return     */    public static int getPascalParams(int n, int k) {        if (n == k) {            return 1;        }        if (n == 0) {            return 1;        }        if (k == 1) {            return 1;        }        if (n == 1) {            return 1;        }        return getPascalParams(n - 1, k - 1) + getPascalParams(n - 1, k);    }    /**     * 一个基数b，一个正整数n,求b的n次幂     *     * @param b     * @param n     * @return     */    public static int getExpt(int b, int n) {        if (n == 0) {            return 1;        } else {            return b * getExpt(b, n - 1);        }    }    /**     * 求b的n次幂，线性迭代求法     *     * @param b     * @param n     * @return     */    public static int getExptByIter(int b, int n) {        return getExptByIterator(b, n, 1);    }    public static int getExptByIterator(int b, int counter, int product) {        if (counter == 0) {            return product;        } else {            return getExptByIterator(b, counter - 1, b * product);        }    }    /**     * 一个基数b，一个正整数n,空间和步数是基于n的对数 求b的n次幂     * 递归求法     *     * @param b 基数     * @param n 指数     * @return     */    public static int getExptByOtherway(int b, int n) {        int i = 1;        if (n == 0) {            return 1;        } else if (n % 2 == 0) {            return getSquare(getExptByOtherway(b, n / 2));        } else {            return b * getExptByOtherway(b, n - 1);        }    }    /**     * b的n次幂线性迭代log求法     *     * @param b     * @param n     * @param product     * @return     */    public static int getExpt(int b, int n, int product) {        if (n == 0) {            return product;        } else if (n % 2 == 0) {            return getExpt(getSquare(b), n / 2, product);        } else {            return getExpt(b, n - 1, b * product);        }    }    /**     * 线性迭代求幂     *     * @param b 基数     * @param n 指数     * @return b的n次幂     */    public static int getExptIter(int b, int n) {        return getExpt(b, n, 1);    }    public static  int multiplication(int a,int b){        if (b ==0){            return 0;        }else{            return a+multiplication(a,b-1);        }    }    /**     * 欧几里得算法求最大公约数     * @param a     * @param b     * @return     */    public static int gcd(int a,int b){        if (b==0){            return a;        }else{            return gcd(b,a%b);        }    }    /**     * 检查从2开始的连续整数能否整除n     * @param n     * @return     */    public static int smalleseDivisor(int n){        return findDivisor(n,2);    }    /**     * 检查testDivisor是否能整除n     * @param n     * @param testDivisor     * @return     */    public static int findDivisor(int n,int testDivisor){        if (getSquare(testDivisor) >n){            return n;        }else if (n%testDivisor == 0){            return testDivisor;        }else{            return findDivisor(n,testDivisor+1);        }    }    /**     * 检查一个数是否是质数：n是素数当且仅当它是自己的最小因子     * @param n     * @return     */    public static boolean getPrime(int n){        if (n == smalleseDivisor(n)){            return true;        }else{            return false;        }    }    /**     * 计算一个数的幂对另一个数取模n的余数。     * @param base     * @param exp     * @param m     * @return     */    public static int expmod(int base,int exp,int m){        if (exp == 0){            return  1;        }else if (exp%2 == 0){            return getSquare(expmod(base,exp/2,m))%m;        }else{           return (base*expmod(base,exp-1,m))%m;        }    }    /**     * 费马检查（费马小定理）     * 对于给定的整数n，随机任取一个a<n并计算出a的n次幂     * 如果得到的结果不等于a，那么n就肯定不是素数。     * 如果它就是a,那么n是素数的机会就很大。     * @param n     * @return     */    public static boolean fermatTest(int n){        return expmod(tryIt(n),n,n)==tryIt(n);    }    /**     * 返回位于1到n-1之间的书a     * @param n     * @return     */    public static int tryIt(int n){        return new Random(n-1).nextInt()+1;    }    public static boolean fastPrime(int n,int times){        if (times == 0){            return  true;        }else if (fermatTest(n)){            return fastPrime(n,times-1);        }else{            return false;        }    }    /**     * 计算a到b的各整数之和     * @param a     * @param b     * @return     */    public static int sumAtoB(int a,int b){        if (a>b){            return 0;        }else {            return a+sumAtoB(a+1,b);        }    }    public static void main(String[] args) {       /* System.out.println("getSquare(-2) = " + getSquare(-2));        System.out.println("getFactorial(5) = " + getFactorial(5));        System.out.println("getFactorialByIterator(5) = " + getFactorialByIterator(6));        System.out.println("getAckermann(2,4) = " + getAckermann(2,4));        System.out.println("getAckermann(3,3) = " + getAckermann(3,3));        System.out.println("getAckermann(0,2) = " + getAckermann(0,2));        System.out.println("getAckermann(0,3) = " + getAckermann(0,3));        System.out.println("getAckermann(0,4) = " + getAckermann(0,4));*/        /*System.out.println("countChange(100,5) = " + countChange(100,5));        System.out.println("countChange(100,4) = " + countChange(100,4));        System.out.println("countChange(100,3) = " + countChange(100,3));        System.out.println("countChange(100,2) = " + countChange(100,2));        System.out.println("countChange(100,1) = " + countChange(100,1));        System.out.println("countChange(100,0) = " + countChange(100,0));*/        /*System.out.println("amountChangeByIterator(100) = " + amountChangeByIterator(11));        System.out.println("getFn(2,1,0,3) = " + getFn(5));        System.out.println("getPascalParams(5,4) = " + getPascalParams(5,4));*/        System.out.println("getExptByOtherway(2,4) = " + getExptByOtherway(2, 5));        System.out.println("getExptIter(2,6) = " + getExptIter(2, 6));        System.out.println("getPrime(4) = " + getPrime(4));        System.out.println("smalleseDivisor(1999) = " + smalleseDivisor(1999));    }}